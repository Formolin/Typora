# 单点登录系统机制

## HTTP 无状态协议

`web` 应用采用 `browser/server` 架构，`http` 作为通信协议。`http` 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fabuwgsj30c00dtdfp.jpg)

但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 `http` 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制

## 会话机制

浏览器第一次请求服务器，服务器创建一个会话，并将会话的 `id` 作为响应的一部分发送给浏览器，浏览器存储会话 `id`，并在后续第二次和第三次请求中带上会话 `id`，服务器取得请求中的会话 `id` 就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fanixcsj30et0dtdfr.jpg)

服务器在内存中保存会话的两种方式

- 请求参数
- Cookie

将会话 `id` 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 `id`，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话 `id` 吧，每次发送 `http` 请求时浏览器自动发送会话 `id`，`cookie` 机制正好用来做这件事。`cookie` 是浏览器用来存储少量数据的一种机制，数据以 `key/value` 形式存储，浏览器发送 `http` 请求时自动附带 `cookie` 信息

`tomcat` 会话机制当然也实现了 `cookie`，访问 `tomcat` 服务器时，浏览器中可以看到一个名为 `JSESSIONID` 的 `cookie`，这就是 `tomcat` 会话机制维护的会话 `id`，使用了 `cookie` 的请求响应过程如下图

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fan1dryj30f90dtq2v.jpg)

## 登录状态

有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，`tomcat` 在会话对象中设置登录状态如下

```text
HttpSession session = request.getSession();
session.setAttribute("isLogin", true);
```



用户再次访问时，`tomcat` 在会话对象中查看登录状态

```text
HttpSession session = request.getSession();
session.getAttribute("isLogin");
```



实现了登录状态的浏览器请求服务器模型如下图描述

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fampmjpj30is0fw3yk.jpg)

每次请求受保护资源时都会检查会话对象中的登录状态，只有 `isLogin=true` 的会话才能访问，登录机制因此而实现

# 多系统登录的复杂性

`eb` 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fl6fjpdj308q0a0weh.jpg)

`web` 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 `web`系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 `web` 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fl6smufj30af0fugll.jpg)

虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？

单系统登录解决方案的核心是 `cookie`，`cookie` 携带会话 `id` 在浏览器与服务器之间维护会话状态。但 `cookie` 是有限制的，这个限制就是 `cookie` 的域（通常对应网站的域名），浏览器发送 `http` 请求时会自动携带与该域匹配的 `cookie`，而不是所有 `cookie`

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fl78mdlj30jj0fdaa1.jpg)

既然这样，为什么不将 `web` 应用群中所有子系统的域名统一在一个顶级域名下，例如 `*.baidu.com`，然后将它们的 `cookie` 域设置为 `baidu.com`，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 `cookie` 的方式。

然而，可行并不代表好，共享 `cookie` 的方式存在众多局限。

- 首先，应用群域名得统一；
- 其次，应用群各系统使用的技术（至少是 `web` 服务器）要相同，不然 `cookie` 的 `key` 值（`tomcat` 为 `JSESSIONID`）不同，无法维持会话，共享 `cookie` 的方式是无法实现跨语言技术平台登录的，比如`java`、`php`、`python` 系统之间；
- 第三，`cookie` 本身不安全。

因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是 **单点登录**

## 什么是单点登录

什么是单点登录？单点登录全称 Single Sign On（以下简称 SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分

## 单点登录

相比于单系统登录，`sso` 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，`sso` 认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fmdlgwej30u00wjdga.jpg)

下面对上图简要描述

- 用户访问系统 1 的受保护资源，系统1发现用户未登录，跳转至 `sso` 认证中心，并将自己的地址作为参数
- `sso` 认证中心发现用户未登录，将用户引导至登录页面
- 用户输入用户名密码提交登录申请
- `sso` 认证中心校验用户信息，创建用户与 `sso` 认证中心之间的会话，称为全局会话，同时创建授权令牌
- `sso` 认证中心带着令牌跳转会最初的请求地址（系统1）
- 系统1拿到令牌，去 `sso` 认证中心校验令牌是否有效
- `sso` 认证中心校验令牌，返回有效，注册系统 1
- 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
- 用户访问系统 2 的受保护资源
- 系统2发现用户未登录，跳转至 `sso` 认证中心，并将自己的地址作为参数
- `sso` 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌
- 系统 2 拿到令牌，去 `sso` 认证中心校验令牌是否有效
- `sso` 认证中心校验令牌，返回有效，注册系统 2
- 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源

用户登录成功之后，会与 `sso` 认证中心及各个子系统建立会话，用户与 `sso` 认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过 `sso` 认证中心，全局会话与局部会话有如下约束关系

- 局部会话存在，全局会话一定存在
- 全局会话存在，局部会话不一定存在
- 全局会话销毁，局部会话必须销毁

## 单点注销

单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35fmdu2i7j30qh0goq30.jpg)

`sso` 认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作

- 用户向系统 1 发起注销请求
- 系统1根据用户与系统1建立的会话 `id` 拿到令牌，向 `sso` 认证中心发起注销请求
- `sso` 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址
- `sso` 认证中心向所有注册系统发起注销请求
- 各注册系统接收 `sso` 认证中心的注销请求，销毁局部会话
- `sso` 认证中心引导用户至登录页面

## 部署图

单点登录涉及 `sso` 认证中心与众子系统，子系统与 `sso` 认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成 `sso` 的客户端，`sso` 认证中心则是 `sso` 服务端，整个单点登录过程实质是 `sso` 客户端与服务端通信的过程，用下图描述

![img](/Users/liujiang/Documents/Typora/imgs/006tNc79ly1g35g5s31h7j30ma0gq74s.jpg)

`sso` 认证中心与 `sso` 客户端通信方式有多种，`HttpClient`，`WebService`、`rpc`、`restful api` 都可以

## 实现原理

### SSO Client

- 拦截子系统未登录用户请求，跳转至 `sso` 认证中心
- 接收并存储 `sso` 认证中心发送的令牌
- 与 `SSO Server` 通信，校验令牌的有效性
- 建立局部会话
- 拦截用户注销请求，向 `sso` 认证中心发送注销请求
- 接收 `sso` 认证中心发出的注销请求，销毁局部会话

### SSO Server

- 验证用户的登录信息
- 创建全局会话
- 创建授权令牌
- 与 `SSO Client` 通信发送令牌
- 校验 `SSO Client` 令牌有效性
- 系统注册
- 接收 `SSO Client` 注销请求，注销所有会话

# 创建服务

token-service-sso

单点登录系统肯定要和数据库打交道

Pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.aishang</groupId>
        <artifactId>token-dependencies</artifactId>
        <version>1.0.0-SNAPSHOT</version>
        <relativePath>../token-dependencies/pom.xml</relativePath>
    </parent>

    <artifactId>token-service-sso</artifactId>
    <packaging>jar</packaging>

    <name>token-service-sso</name>

    <dependencies>

        <!-- Spring Boot Begin -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Spring Boot End -->
        <!--zipkin-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zipkin</artifactId>
        </dependency>

        <!--分布式配置中心-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <!--springboot admin client-->
        <dependency>
            <groupId>org.jolokia</groupId>
            <artifactId>jolokia-core</artifactId>
        </dependency>
        <dependency>
            <groupId>de.codecentric</groupId>
            <artifactId>spring-boot-admin-starter-client</artifactId>
        </dependency>


        <!--druid-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
        </dependency>
        <!--mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!--代替mybatis-->
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper-spring-boot-starter</artifactId>
        </dependency>
        <!--pageHelper-->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
        </dependency>
        <!--fastjson-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- 服务提供者Spring Cloud Begin -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        <!-- Spring Cloud End -->


        <!--服务消费者feign-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <dependency>
            <groupId>com.aishang</groupId>
            <artifactId>token-domain</artifactId>
            <version>${project.parent.version}</version>
        </dependency>
        <dependency>
            <groupId>com.aishang</groupId>
            <artifactId>token-provider-common</artifactId>
            <version>1.0.0-SNAPSHOT</version>
        </dependency>




        <!-- 解决 thymeleaf 模板引擎一定要执行严格的 html5 格式校验问题 -->
        <dependency>
            <groupId>net.sourceforge.nekohtml</groupId>
            <artifactId>nekohtml</artifactId>
            <version>1.9.22</version>
        </dependency>

    </dependencies>
    <!--nexus地址 获取依赖-->
    <repositories>
        <repository>
            <id>nexus</id>
            <name>Nexus Repository</name>
            <url>http://192.168.83.200:8081/repository/maven-public/</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>
    </repositories>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>com.aishang.token.service.sso.SsoApplication</mainClass>
                </configuration>
            </plugin>
            <!--tk.mybatis-->
            <plugin>
                <groupId>org.mybatis.generator</groupId>
                <artifactId>mybatis-generator-maven-plugin</artifactId>
                <version>1.3.5</version>
                <configuration>
                    <configurationFile>${basedir}/src/main/resources/generator/generatorConfig.xml</configurationFile>
                    <overwrite>true</overwrite>
                    <verbose>true</verbose>
                </configuration>
                <dependencies>
                    <dependency>
                        <groupId>mysql</groupId>
                        <artifactId>mysql-connector-java</artifactId>
                        <version>${mysql.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>tk.mybatis</groupId>
                        <artifactId>mapper</artifactId>
                        <version>3.4.4</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
</project>
```

bootstrap.yml

```yml
spring:
  cloud:
    config:
      uri: http://localhost:8888
      name: token-service-sso
      label: master
      profile: dev
```

bootstrap-prod.yml

```yml
spring:
  cloud:
    config:
      uri: http://192.168.83.200:8888
      name: token-service-sso
      label: master
      profile: prod
```

SsoApplication

他是服务提供者，但是还需要拿redis的数据，也是消费者

```java
package com.aishang.token.service.sso;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import tk.mybatis.spring.annotation.MapperScan;

@EnableDiscoveryClient
@EnableEurekaClient
@SpringBootApplication
@EnableFeignClients

public class SsoApplication {
    public static void main(String[] args) {
        SpringApplication.run(SsoApplication.class,args);
    }
}

```

那么问题是，这里需要依赖domain，provider也依赖domain

重构项目

新建token-domain

pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.aishang</groupId>
        <artifactId>token-dependencies</artifactId>
        <version>1.0.0-SNAPSHOT</version>
        <relativePath>../token-dependencies/pom.xml</relativePath>
    </parent>

    <artifactId>token-domain</artifactId>
    <packaging>jar</packaging>

    <name>token-domain</name>

    <dependencies>

        <dependency>
            <groupId>javax.persistence</groupId>
            <artifactId>persistence-api</artifactId>
            <version>1.0</version>
        </dependency>
    </dependencies>

    <!--<build>-->
        <!--<plugins>-->
            <!--<plugin>-->
                <!--<groupId>org.springframework.boot</groupId>-->
                <!--<artifactId>spring-boot-maven-plugin</artifactId>-->
                <!--<configuration>-->
                    <!--<mainClass>com.aishang.token.pojo.DomainApplication</mainClass>-->
                <!--</configuration>-->
            <!--</plugin>-->

        <!--</plugins>-->
    <!--</build>-->
</project>
```

把之前的mapper复制过来

token-config

token-service-sso-dev.yml

```yml
spring:
  application:
    name: token-service-sso
    #给项目起名，服务注册与发现，别人通过项目名找到服务
  zipkin:
    base-url: http://localhost:9411

  boot:
    admin:
      client:
        url: http://localhost:8084
  datasource:
    druid:
      url: jdbc:mysql://localhost:3306/token-service-provider?useUnicode=true&characterEncoding=utf-8&useSSL=false
      username: root
      password: password
      initial-size: 1
      min-idle: 1
      max-active: 20
      test-on-borrow: true
      # MySQL 8.x: com.mysql.cj.jdbc.Driver
      driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    cache: false
    mode: LEGACYHTML5
    encoding: UTF-8
    servlet:
      content-type: text/html

mybatis:
  type-aliases-package: com.aishang.token.pojo
  mapper-locations: classpath:mapper/*.xml

server:
  port: 8503

fegin:
  hystrix:
    enabled: true

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/


management:
  endpoint:
    health:
      show-details: always
  endpoints:
    web:
      exposure:
        include: health, info
```

token-service-sso-prod.yml

```yml
spring:
  application:
    name: token-service-sso
    #给项目起名，服务注册与发现，别人通过项目名找到服务
  zipkin:
    base-url: http://192.168.83.200:9411

  boot:
    admin:
      client:
        url: http://192.168.83.200:8084
  datasource:
    druid:
      url: jdbc:mysql://192.168.83.200:3306/token-service-provider?useUnicode=true&characterEncoding=utf-8&useSSL=false
      username: root
      password: password
      initial-size: 1
      min-idle: 1
      max-active: 20
      test-on-borrow: true
      # MySQL 8.x: com.mysql.cj.jdbc.Driver
      driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    cache: false
    mode: LEGACYHTML5
    encoding: UTF-8
    servlet:
      content-type: text/html

mybatis:
  type-aliases-package: com.aishang.token.pojo
  mapper-locations: classpath:mapper/*.xml

server:
  port: 8503

fegin:
  hystrix:
    enabled: true

eureka:
  client:
    serviceUrl:
      defaultZone: http://192.168.83.200:8761/eureka/,http://192.168.83.200:8861/eureka/,http://192.168.83.200:8961/eureka/


management:
  endpoint:
    health:
      show-details: always
  endpoints:
    web:
      exposure:
        include: health, info
```

还需要添加thymeleaf依赖等，在修改config文件，因为需要单点登录，如果失败，需要跳到登录页面

TbSysUserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.aishang.token.service.sso.mapper.TbSysUserMapper">
  <!--扫描的mapper接口的位置-->
  <resultMap id="BaseResultMap" type="com.aishang.token.pojo.TbSysUser">
    <!--扫描的是存放实体类的位置-->
    <!--
      WARNING - @mbg.generated
    -->
    <id column="user_code" jdbcType="VARCHAR" property="userCode" />
    <result column="login_code" jdbcType="VARCHAR" property="loginCode" />
    <result column="user_name" jdbcType="VARCHAR" property="userName" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="email" jdbcType="VARCHAR" property="email" />
    <result column="mobile" jdbcType="VARCHAR" property="mobile" />
    <result column="phone" jdbcType="VARCHAR" property="phone" />
    <result column="sex" jdbcType="CHAR" property="sex" />
    <result column="avatar" jdbcType="VARCHAR" property="avatar" />
    <result column="sign" jdbcType="VARCHAR" property="sign" />
    <result column="wx_openid" jdbcType="VARCHAR" property="wxOpenid" />
    <result column="mobile_imei" jdbcType="VARCHAR" property="mobileImei" />
    <result column="user_type" jdbcType="VARCHAR" property="userType" />
    <result column="ref_code" jdbcType="VARCHAR" property="refCode" />
    <result column="ref_name" jdbcType="VARCHAR" property="refName" />
    <result column="mgr_type" jdbcType="CHAR" property="mgrType" />
    <result column="pwd_security_level" jdbcType="DECIMAL" property="pwdSecurityLevel" />
    <result column="pwd_update_date" jdbcType="TIMESTAMP" property="pwdUpdateDate" />
    <result column="pwd_update_record" jdbcType="VARCHAR" property="pwdUpdateRecord" />
    <result column="pwd_question" jdbcType="VARCHAR" property="pwdQuestion" />
    <result column="pwd_question_answer" jdbcType="VARCHAR" property="pwdQuestionAnswer" />
    <result column="pwd_question_2" jdbcType="VARCHAR" property="pwdQuestion2" />
    <result column="pwd_question_answer_2" jdbcType="VARCHAR" property="pwdQuestionAnswer2" />
    <result column="pwd_question_3" jdbcType="VARCHAR" property="pwdQuestion3" />
    <result column="pwd_question_answer_3" jdbcType="VARCHAR" property="pwdQuestionAnswer3" />
    <result column="pwd_quest_update_date" jdbcType="TIMESTAMP" property="pwdQuestUpdateDate" />
    <result column="last_login_ip" jdbcType="VARCHAR" property="lastLoginIp" />
    <result column="last_login_date" jdbcType="TIMESTAMP" property="lastLoginDate" />
    <result column="freeze_date" jdbcType="TIMESTAMP" property="freezeDate" />
    <result column="freeze_cause" jdbcType="VARCHAR" property="freezeCause" />
    <result column="user_weight" jdbcType="DECIMAL" property="userWeight" />
    <result column="status" jdbcType="CHAR" property="status" />
    <result column="create_by" jdbcType="VARCHAR" property="createBy" />
    <result column="create_date" jdbcType="TIMESTAMP" property="createDate" />
    <result column="update_by" jdbcType="VARCHAR" property="updateBy" />
    <result column="update_date" jdbcType="TIMESTAMP" property="updateDate" />
    <result column="remarks" jdbcType="VARCHAR" property="remarks" />
    <result column="corp_code" jdbcType="VARCHAR" property="corpCode" />
    <result column="corp_name" jdbcType="VARCHAR" property="corpName" />
    <result column="extend_s1" jdbcType="VARCHAR" property="extendS1" />
    <result column="extend_s2" jdbcType="VARCHAR" property="extendS2" />
    <result column="extend_s3" jdbcType="VARCHAR" property="extendS3" />
    <result column="extend_s4" jdbcType="VARCHAR" property="extendS4" />
    <result column="extend_s5" jdbcType="VARCHAR" property="extendS5" />
    <result column="extend_s6" jdbcType="VARCHAR" property="extendS6" />
    <result column="extend_s7" jdbcType="VARCHAR" property="extendS7" />
    <result column="extend_s8" jdbcType="VARCHAR" property="extendS8" />
    <result column="extend_i1" jdbcType="DECIMAL" property="extendI1" />
    <result column="extend_i2" jdbcType="DECIMAL" property="extendI2" />
    <result column="extend_i3" jdbcType="DECIMAL" property="extendI3" />
    <result column="extend_i4" jdbcType="DECIMAL" property="extendI4" />
    <result column="extend_f1" jdbcType="DECIMAL" property="extendF1" />
    <result column="extend_f2" jdbcType="DECIMAL" property="extendF2" />
    <result column="extend_f3" jdbcType="DECIMAL" property="extendF3" />
    <result column="extend_f4" jdbcType="DECIMAL" property="extendF4" />
    <result column="extend_d1" jdbcType="TIMESTAMP" property="extendD1" />
    <result column="extend_d2" jdbcType="TIMESTAMP" property="extendD2" />
    <result column="extend_d3" jdbcType="TIMESTAMP" property="extendD3" />
    <result column="extend_d4" jdbcType="TIMESTAMP" property="extendD4" />
  </resultMap>
</mapper>
```

### LoginController

```java
package com.aishang.token.service.sso.controller;

import com.aishang.token.pojo.TbSysUser;
import com.aishang.token.service.sso.service.LoginService;
import com.aishang.token.service.sso.service.consumer.RedisService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;

@Controller
public class LoginController {
    @Resource
    public RedisService redisService;
    @Resource
    public LoginService loginService;
    //跳转登录页面
    @RequestMapping("/login")
    public String login() {
        return "login";
    }
    //登录业务
    @RequestMapping("/loginCheck")
    @ResponseBody
    public String login(String loginCode,String password) {

        TbSysUser login = loginService.login(loginCode, password);

        System.out.println("login-controller=="+login.getLoginCode());
        return "ok";
    }
}

```

### TbSysUserMapper

```java
package com.aishang.token.service.sso.mapper;

import com.aishang.token.pojo.TbSysUser;
import org.apache.ibatis.annotations.Mapper;
import tk.mybatis.mapper.MyMapper;

@Mapper
public interface TbSysUserMapper extends MyMapper<TbSysUser> {
}
```

### LoginService

```java
package com.aishang.token.service.sso.service;

import com.aishang.token.pojo.TbSysUser;

public interface LoginService {

    public TbSysUser login(String loginCode,String plantPassword);
}

```

### LoginServiceImpl

```java
package com.aishang.token.service.sso.service.impl;

import com.aishang.token.pojo.TbSysUser;
import com.aishang.token.service.sso.mapper.TbSysUserMapper;
import com.aishang.token.service.sso.service.LoginService;
import com.aishang.token.service.sso.service.consumer.RedisService;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import org.springframework.stereotype.Service;
import org.springframework.util.DigestUtils;
import tk.mybatis.mapper.entity.Example;

import javax.annotation.Resource;

@Service
public class LoginServiceImpl implements LoginService {
    @Resource
    TbSysUserMapper tbSysUserMapper;
    @Resource
    RedisService redisService;

    @Override
    public TbSysUser login(String loginCode, String plantPassword) {
        TbSysUser tbSysUser = null;
        //单点登录先上redis里取用户信息，如果没有，在上数据库取，在把数据存到redis里
        String json = redisService.get(loginCode);
        System.out.println("login------json"+json);
        if (json.equals("null")){
            System.out.println("redis中没有，先去查数据库");
            tbSysUser = tbSysUserMapper.selectOne(tbSysUser);
            System.out.println(tbSysUser.getLoginCode());
            System.out.println(tbSysUser.getPassword());
            if (plantPassword.equals(tbSysUser.getPassword())){
                //数据库里有，登录成功，需要存到redis

                //把这个对象转成json字符串存进去
                json = JSON.toJSONString(tbSysUser);
                System.out.println("登录成功，需要存到redis====" + json);
                String set = redisService.set(loginCode, json, 60 * 60 * 24);
                System.out.println("set==" + set);
                return tbSysUser;
            }
        }else{
            System.out.println("login------json"+json);
            System.out.println("redis里有，登录成功");
            Object parse = JSON.parse(json);
            System.out.println(parse+"===parse");
            //这里往redis存的json，接受到后里面有转义字符\，需要先解析成正确的json，返回的是object，在转成json字符串，在转成对象
            String s = JSON.toJSONString(parse);
            System.out.println("s========"+s);
            tbSysUser = JSON.parseObject(s, TbSysUser.class);
            System.out.println("tbsys==="+tbSysUser);
        }

        return tbSysUser;
    }
}


```

### RedisService

```java
package com.aishang.token.service.sso.service.consumer;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(value = "token-service-redis")
public interface RedisService {
    @RequestMapping("/put")
    public String set(@RequestParam(value = "key") String key,@RequestParam(value = "value") String value,@RequestParam(value = "seconds") long seconds);

    @RequestMapping("/find")
    public String get(@RequestParam(value = "key") String key) ;
}

```



测试

```sh
http://127.0.0.1:8503/loginCheck?loginCode=admin&password=123456

ok


http://127.0.0.1:8503/login

登录页面
```

![token____Documents_IDEA_token__-_____token-service-sso_src_main_java_com_aishang_token_service_sso_service_consumer_RedisService_java__token-service-sso_](https://ws2.sinaimg.cn/large/006tNc79ly1g35jacorf3j30fc0oqjt5.jpg)

# Spring Boot 配置拦截器

## 定义拦截器

```text
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        return true;//如果为false，所有都拦截，不到postHandle
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {

    }
}
```

## 配置拦截器

```text
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");
    }
}
```

### 单点登录思路：

- 所有登陆业务，都需要单点登录中心，token-service-sso
- 此服务只处理登录注册注销操作

- 用户访问A系统的登录页面，进行登录操作
  - 验证用户
    - 先查询redis里有没有用户信息，如果有，登录成功，并返回用户信息(减少一次数据库操作)
    - 如果没有，查询数据库，如果有，登录成功，并把信息保存到redis里，如果没有返回到登陆页面，并提示错误信息
- 登陆成功后，用户在访问B系统
  - 此时做单点登录，需要满足同源策略和cookie的jsessionid一致，确认是一个用户，同源策略这样的话，下次访问相关系统时，会带回cookie，cookie里存一个键，比如是uuid，值是redis里的键，这样就都能拿到redis的值
  - 那么在上面的代码中添加cookie的代码
  - 如果我在A系统中输入B系统的主页页面，需要判断是否登陆过，如果登陆过，那么放行，可以访问，如果没有登陆过，那么就是从localhost:91跳到localhost:92,此时在让他跳到sso中的登录页面
  - 就需要拦截器，进行登录验证

代码：

### token-service-consumer

##### success.html

```html
<!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/success.css">
</head>
<body>
<h1>来到token-service-consumer 登陆成功后的页面</h1>
<a th:href="@{/miaosha}">秒杀系统</a>
</body>
</html>
```

##### Index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>consumer</title>
</head>
<body>
<h1>我是token-consumer的<span style="color: red">秒杀</span>主页面</h1>
</body>
</html>
```



##### UserController

```java
package com.aishang.token.service.consumer.controller;

import com.aishang.token.service.consumer.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@Controller
public class UserController {
    @Autowired
    private UserService userService;

    @RequestMapping("/hi")
    @ResponseBody
    public String sayHi(String message) {
        String s = userService.sayHi(message);
        return s;
    }

    @RequestMapping("/success")
    public String success() {
        System.out.println("接到sso登陆成成功信息");
        return "success";
    }

}

```



### token-service-redis

## RedisController

```java
package com.aishang.token.service.redis.Controller;

import com.aishang.token.service.redis.service.RedisService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
public class RedisController {
    private static final String RESULT_OK = "success";

    @Resource
    private RedisService redisService;

    @RequestMapping(value = "put", method = RequestMethod.GET)
    public String set(String key, String value, long seconds) {

        System.out.println("redis-put  添加成功");
        redisService.set(key, value, seconds);
        return RESULT_OK;
    }

    @RequestMapping(value = "find", method = RequestMethod.GET)
    public String get(String key) {
        String json = null;
        System.out.println("key ===" +key);
        Object obj = redisService.get(key);
        System.out.println("redis obj=="+obj);
        if (obj != null) {
            json = (String) redisService.get(key);
            return json;
        }

        return json;
    }
}

```

## RedisServiceImpl

```java
package com.aishang.token.service.redis.service.impl;

import com.aishang.token.service.redis.service.RedisService;
import com.alibaba.fastjson.JSON;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;
@Service
public class RedisServiceImpl implements RedisService {
    @Autowired
    private RedisTemplate redisTemplate;
    @Override
    public void set(String key, Object value, long seconds) {
        redisTemplate.opsForValue().set(key, value, seconds, TimeUnit.SECONDS);
    }

    @Override
    public String get(String key) {
        System.out.println("redisTemplate.opsForValue().get(key)="+key+"====="+redisTemplate.opsForValue().get(key));

        return redisTemplate.opsForValue().get(key)+"";
    }
}

```



### token-service-sso

##### Login.html

```html
<!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>登录</title>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <link rel="stylesheet" type="text/css" href="css/shopping-mall-index.css"/>
    <link rel="stylesheet" type="text/css" href="css/zhonglingxm2.css"/>
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="js/zhonglin.js"></script>
</head>

<body>

<div class="sign-logo w1200">
    <h1 class="zl-h11"><a href="success.html" title="宅客微购"><img src="images/zl2-01.gif"/></a></h1>
</div>

<div class="sign-con w1200">
    <img src="images/logn-tu.gif" class="sign-contu f-l"/>
    <form action="#" th:action="@{${#request.getContextPath()}+'/loginok'}" method="post">
        <div class="sign-ipt f-l">
            <p>用户名</p>
            <input type="text" placeholder="手机号/邮箱" name="loginCode"/>
            <p>密码</p>
            <input type="text" placeholder="密码可见" name="password"/><br/>
            <button class="slig-btn">登录</button>
            <p>已有账号？请<a href="#">登录</a><a href="#" class="wj">忘记密码？</a></p>
            <div class="sign-qx">
                <a href="#" class="f-r"><img src="images/sign-xinlan.gif"/></a>
                <a href="#" class="qq f-r"><img src="images/sign-qq.gif"/></a>
                <div style="clear:both;"></div>
            </div>
        </div>
    </form>


    <div style="clear:both;"></div>
</div>

<!--底部一块-->
<div class="footer-box">
    <ul class="footer-info1 w1200">
        <li>
            <div class="ft-tu1">
                <a href="JavaScript:;"><img src="images/zl2-86.gif"/></a>
            </div>
            <h3><a href="JavaScript:;">号码保障</a></h3>
            <P>所有会员，手机短信验证</P>
        </li>
        <li>
            <div class="ft-tu1">
                <a href="JavaScript:;"><img src="images/zl2-87.gif"/></a>
            </div>
            <h3><a href="JavaScript:;">6*12小时客服</a></h3>
            <P>有任何问题随时免费资讯</P>
        </li>
        <li>
            <div class="ft-tu1">
                <a href="JavaScript:;"><img src="images/zl2-88.gif"/></a>
            </div>
            <h3><a href="JavaScript:;">专业专攻</a></h3>
            <P>我们只专注于建筑行业的信息服务</P>
        </li>
        <li>
            <div class="ft-tu1">
                <a href="JavaScript:;"><img src="images/zl2-89.gif"/></a>
            </div>
            <h3><a href="JavaScript:;">注册有礼</a></h3>
            <P>随时随地注册有大礼包</P>
        </li>
        <li>
            <div class="ft-tu1">
                <a href="JavaScript:;"><img src="images/zl2-90.gif"/></a>
            </div>
            <h3><a href="JavaScript:;">值得信赖</a></h3>
            <P>专业的产品，专业的团队</P>
        </li>
        <div style="clear:both;"></div>
    </ul>
    <div class="footer-info2 w1200">
        <div class="ft-if2-left f-l">
            <dl>
                <dt><a href="6-1服务协议.html">新手上路</a></dt>
                <dd>
                    <a href="6-1服务协议.html">购物流程</a>
                    <a href="6-1服务协议.html">在线支付</a>
                    <a href="6-1服务协议.html">投诉与建议</a>
                </dd>
            </dl>
            <dl>
                <dt><a href="6-1服务协议.html">配送方式</a></dt>
                <dd>
                    <a href="6-1服务协议.html">货到付款区域</a>
                    <a href="6-1服务协议.html">配送费标准</a>
                </dd>
            </dl>
            <dl>
                <dt><a href="6-1服务协议.html">购物指南</a></dt>
                <dd>
                    <a href="6-1服务协议.html">订购流程</a>
                    <a href="6-1服务协议.html">购物常见问题</a>
                </dd>
            </dl>
            <dl>
                <dt><a href="6-1服务协议.html">售后服务</a></dt>
                <dd>
                    <a href="6-1服务协议.html">售后服务保障</a>
                    <a href="6-1服务协议.html">退换货政策总则</a>
                    <a href="6-1服务协议.html">自营商品退换细则</a>
                </dd>
            </dl>
            <div style="clear:both;"></div>
        </div>
        <div class="ft-if2-right f-r">
            <h3>400-2298-223</h3>
            <p>周一至周日 9:00-24:00</p>
            <p>（仅收市话费）</p>
        </div>
        <div style="clear:both;"></div>
    </div>
    <div class="footer-info3 w1200">
        <p>
            <a href="#">免责条款</a><span>|</span>
            <a href="#">隐私保护</a><span>|</span>
            <a href="#">咨询热点</a><span>|</span>
            <a href="#">联系我们</a><span>|</span>
            <a href="#">公司简介</a>
        </p>
        <p>
            <a href="#">沪ICP备13044278号</a><span>|</span>
            <a href="#">合字B1.B2-20130004</a><span>|</span>
            <a href="#">营业执照</a><span>|</span>
            <a href="#">互联网药品信息服务资格证</a><span>|</span>
            <a href="#">互联网药品交易服务资格证</a>
        </p>
        <div class="ft-if3-tu1">
            <a href="#"><img src="images/zl2-91.gif"/></a>
            <a href="#"><img src="images/zl2-92.gif"/></a>
            <a href="#"><img src="images/zl2-93.gif"/></a>
        </div>
    </div>
</div>
</body>
</html>

```

##### LoginController

```java
package com.aishang.token.service.sso.controller;

import com.aishang.token.pojo.TbSysUser;
import com.aishang.token.service.sso.service.LoginService;
import com.aishang.token.service.sso.service.consumer.RedisService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;

@Controller
public class LoginController {
    @Resource
    public RedisService redisService;
    @Resource
    public LoginService loginService;
    //跳转登录页面
    @RequestMapping("/login")
    public String login() {
        System.out.println("访问登录页面，跳转到登陆页面");
        return "login";
    }
    //登录业务
    @RequestMapping("/loginok")
    public String login(String loginCode,String password) {
        System.out.println("logincode="+loginCode);
        //登陆系统，如果查询到
        TbSysUser login = loginService.login(loginCode, password);
        //如果为null，登录失败
        if (login!=null){
            System.out.println("登陆成功，跳转到其他项目的主页面 比如跳转consumer中的主页面");
            //consumer的地址，可以写在配置文件中，这里通过注解@Value（）去个成员变量赋值，这里直接写死了
            return "redirect:http://127.0.0.1:8601/success";
        }else{
            System.out.println("回到登陆页面");
            return "login";
        }

    }
}

```

##### RedisService

```java
package com.aishang.token.service.sso.service.consumer;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(value = "token-service-redis")
public interface RedisService {
    @RequestMapping("/put")
    public String set(@RequestParam(value = "key") String key,@RequestParam(value = "value") String value,@RequestParam(value = "seconds") long seconds);

    @RequestMapping("/find")
    public String get(@RequestParam(value = "key") String key) ;
}

```

##### LoginServiceImpl

```java
package com.aishang.token.service.sso.service.impl;

import com.aishang.token.pojo.TbSysUser;
import com.aishang.token.service.sso.mapper.TbSysUserMapper;
import com.aishang.token.service.sso.service.LoginService;
import com.aishang.token.service.sso.service.consumer.RedisService;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import org.springframework.stereotype.Service;
import org.springframework.util.DigestUtils;
import tk.mybatis.mapper.entity.Example;

import javax.annotation.Resource;

@Service
public class LoginServiceImpl implements LoginService {
    @Resource
    TbSysUserMapper tbSysUserMapper;
    @Resource
    RedisService redisService;

    @Override
    public TbSysUser login(String loginCode, String plantPassword) {
        TbSysUser tbSysUser = new TbSysUser();
        //单点登录先上redis里取用户信息，如果没有，在上数据库取，在把数据存到redis里

        //后面有个bug，比如我redis里一开始获取的时候，有值，下面在进行判断的时候，时间到了，这时候就已经空了，需要二次判断
        String json = redisService.get(loginCode);
        System.out.println("login------json="+json);
        if (json.equals("null")){
            System.out.println("redis中没有，先去查数据库");
            tbSysUser.setLoginCode(loginCode);
            tbSysUser.setPassword(plantPassword);
            tbSysUser = tbSysUserMapper.selectOne(tbSysUser);
            if (tbSysUser!=null){
                //数据库里有，登录成功，需要存到redis

                //把这个对象转成json字符串存进去
                json = JSON.toJSONString(tbSysUser);
                System.out.println("登录成功，需要存到redis====" + json);
                String set = redisService.set(loginCode, json, 60 * 60 * 24);
                System.out.println("set==" + set);
                return tbSysUser;
            }else{
                //数据库查询，登陆失败，返回登陆失败信息
                System.out.println("数据没有此用户信息，返回null");
                return  null;
            }
        }else{
            System.out.println("login------json"+json);
            System.out.println("redis里有，登录成功");
            if (json==null){
                System.out.println("进行二次判断，防止redis里信息时间过期");
                return  null;
            }
            Object parse = JSON.parse(json);
            System.out.println(parse+"===parse");
            //这里往redis存的json，接受到后里面有转义字符\，需要先解析成正确的json，返回的是object，在转成json字符串，在转成对象
            String s = JSON.toJSONString(parse);
            System.out.println("s========"+s);
            tbSysUser = JSON.parseObject(s, TbSysUser.class);
            System.out.println("tbsys==="+tbSysUser);
        }

        return tbSysUser;
    }
}


```

测试登陆，成功，接着模拟

- [http://127.0.0.1:8601/success](http://127.0.0.1:8601/success)这是登陆成功的地址，如果我直接地址栏访问，没有验证是否登陆过，需要访问此系统所有页面进行登录验证，拦截器，拦截所有资源并且放行静态资源

- 在登陆成功的主页面里，此时已在另一个系统中，网页上新写个连接，秒杀连接，点击此连接，如果登陆过，直接进入秒杀页面，否则回到sso中的登录页面，登录成功后，在跳到秒杀页面

  

### token-service-consumer

新建包interceptor

##### ConsumerInterceptor

```java
package com.aishang.token.service.consumer.interceptor;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class ConsumerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return true;
        //注意这里改成true，才能放行到postHandle中
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("拦截器");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}

```

注意：此时没有生效，需要到主程序中添加注解，让springboot扫描的，默认扫描主程序同包及其子包，需要更改

##### ConsumerFeginApplication

```java
package com.aishang.token.service.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
//报错不用管
@SpringBootApplication(scanBasePackages = "com.aishang.token")
@EnableDiscoveryClient//尤里卡注解 客户端
@EnableFeignClients//服务消费者注解
public class ConsumerFeginApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerFeginApplication.class, args);
    }
}

```



新建包config

##### ConsumerInterceptorConfig

```java
package com.aishang.token.service.consumer.config;

import com.aishang.token.service.consumer.interceptor.ConsumerInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class ConsumerInterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //添加拦截器，通过registry注册
//        registry.addInterceptor(new ConsumerInterceptor()).addPathPatterns("/**").excludePathPatterns("/static");
        registry.addInterceptor(new ConsumerInterceptor()).addPathPatterns("/**").excludePathPatterns("/success");

    }
}

```

